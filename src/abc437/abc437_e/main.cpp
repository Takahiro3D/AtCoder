#include <bits/stdc++.h>

#include <atcoder/all>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
using namespace atcoder;

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int N;
  cin >> N;

  // Accessor for vertex id by original index
  vector<int> vertex_id(N + 1, -1);
  // Trie tree
  vector<map<int, int>> edges;
  // Add root
  vertex_id[0] = 0;
  edges.emplace_back();

  int x, y;
  for (int i = 1; i <= N; i++) {
    cin >> x >> y;
    int v_to;
    int v = vertex_id[x];
    if (!edges[v].contains(y)) {
      v_to = edges.size();   // Get new vertex id
      edges.emplace_back();  // Edges for new vertex
      edges[v][y] = v_to;
    } else {
      v_to = edges[v][y];  // Existing vertex id
    }
    vertex_id[i] = v_to;
  }

  // Reverse lookup for vertex id to original indices
  vector<vector<int>> is(edges.size());
  for (int i = 1; i <= N; i++) {
    is[vertex_id[i]].emplace_back(i);
  }

  // DFS to output indices in pre-order (= dictionary order)
  auto f = [&](auto f, int v) -> void {
    for (int i : is[v]) {
      cout << i << ' ';
    }
    for (auto [_, to_v] : edges[v]) {
      f(f, to_v);
    }
  };
  f(f, 0);

  cout << endl;

  return 0;
}
