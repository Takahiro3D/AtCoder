#include <bits/stdc++.h>

#include <atcoder/all>

#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
using namespace atcoder;

unordered_map<char, pair<int64_t, int64_t>> dir = {
    {'L', {0, -1}},
    {'R', {0, 1}},
    {'U', {-1, 0}},
    {'D', {1, 0}},
};

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int64_t Rt, Ct, Ra, Ca;
  cin >> Rt >> Ct >> Ra >> Ca;
  int64_t N, M, L;
  cin >> N >> M >> L;
  vector<pair<char, int64_t>> t(M);
  REP(i, M) {
    char S;
    int64_t A;
    cin >> S >> A;
    t[i] = {S, A};
  }
  vector<pair<char, int64_t>> a(L);
  REP(i, L) {
    char T;
    int64_t B;
    cin >> T >> B;
    a[i] = {T, B};
  }

  auto move = [&](int64_t& R, int64_t& C, char d, int64_t len) {
    auto [dr, dc] = dir[d];
    R += dr * len;
    C += dc * len;
  };

  int i = 0;
  int j = 0;
  int64_t ans = 0;
  while (i < M || j < L) {
    auto minLen = min(t[i].second, a[j].second);

    auto wasSameRow = Rt == Ra;
    auto wasSameCol = Ct == Ca;

    auto [Tdr, Tdc] = dir[t[i].first];
    auto [Adr, Adc] = dir[a[j].first];

    auto isSameMove = (t[i].first == a[j].first);
    auto isMoveCol = (t[i].first == 'L' && a[j].first == 'R') || (t[i].first == 'R' && a[j].first == 'L');
    auto isMoveRow = (t[i].first == 'U' && a[j].first == 'D') || (t[i].first == 'D' && a[j].first == 'U');

    if (isSameMove) {
      if (wasSameRow && wasSameCol) {
        // same movement
        ans += minLen;
      }
    } else if (isMoveRow) {
      auto x = div(Ra - Rt, Tdr - Adr);
      if (0 < x.quot && x.quot <= minLen && x.rem == 0 && wasSameCol) {
        ans++;
      }
    } else if (isMoveCol) {
      auto y = div(Ca - Ct, Tdc - Adc);
      if (0 < y.quot && y.quot <= minLen && y.rem == 0 && wasSameRow) {
        ans++;
      }
    } else {
      // cross situation
      auto x = div(Ra - Rt, Tdr - Adr);
      auto y = div(Ca - Ct, Tdc - Adc);
      if (x.quot == y.quot && 0 < x.quot && x.quot <= minLen && x.rem == 0 && y.rem == 0) {
        ans++;
      }
    }
    move(Rt, Ct, t[i].first, minLen);
    move(Ra, Ca, a[j].first, minLen);
    t[i].second -= minLen;
    if (t[i].second == 0) i++;
    a[j].second -= minLen;
    if (a[j].second == 0) j++;
  }

  cout << ans << '\n';

  return 0;
}
