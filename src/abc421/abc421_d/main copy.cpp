#include <bits/stdc++.h>

#include <atcoder/all>

#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
using namespace atcoder;

unordered_map<char, pair<int, int>> dir = {
    {'L', {0, -1}},
    {'R', {0, 1}},
    {'U', {-1, 0}},
    {'D', {1, 0}},
};

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int Rt, Ct, Ra, Ca;
  cin >> Rt >> Ct >> Ra >> Ca;
  int N, M, L;
  cin >> N >> M >> L;
  vector<pair<char, int64_t>> t(M);
  REP(i, M) {
    char S;
    int64_t A;
    cin >> S >> A;
    t[i] = {S, A};
  }
  vector<pair<char, int64_t>> a(L);
  REP(i, L) {
    char T;
    int64_t B;
    cin >> T >> B;
    a[i] = {T, B};
  }

  auto move = [&](int& R, int& C, char d, int64_t len) {
    auto [dr, dc] = dir[d];
    R += dr * len;
    C += dc * len;
  };

  int i = 0;
  int j = 0;
  int64_t ans = 0;
  auto isR = [](char c) { return c == 'U' || c == 'D'; };
  while (i < M || j < L) {
    auto minLen = min(t[i].second, a[j].second);

    auto Ct_prev = Ct;
    auto Ca_prev = Ca;
    auto Rt_prev = Rt;
    auto Ra_prev = Ra;
    move(Rt, Ct, t[i].first, minLen);
    move(Ra, Ca, a[j].first, minLen);

    auto isSameRow = Rt == Ra;
    auto isSameCol = Ct == Ca;
    auto isSameMove = (t[i].first == a[j].first) && (Rt == Ra) && (Ct == Ca);
    // auto isSameRow = (!isR(t[i].first) == !isR(a[j].first)) && (Rt == Ra);
    // auto isSameCol = (isR(t[i].first) == isR(a[j].first)) && (Ct == Ca);
    auto isRowCrossed = (Rt_prev < Ra) ^ (Rt < Ra);
    auto isColCrossed = (Ct_prev < Ca) ^ (Ct < Ca);
    if (isSameMove) {
      // same movement
      ans += minLen;
    } else if ((isRowCrossed && isSameCol) || (isColCrossed && isSameRow)) {
      ans++;
      //    } else if (isSameRow) {
      //      // May cross
      //      if ((Ct_prev < Ca_prev) ^ (Ct < Ca)) ans++;
      //    } else if (isSameCol) {
      //      // May cross
      //      if ((Rt_prev < Ra_prev) ^ (Rt < Ra)) ans++;
    } else {
      // No cross
    }
    t[i].second -= minLen;
    if (t[i].second == 0) i++;
    a[j].second -= minLen;
    if (a[j].second == 0) j++;
  }

  cout << ans << '\n';

  return 0;
}
