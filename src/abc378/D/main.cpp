#include <bits/stdc++.h>
using namespace std;

int row[4] = {0, 0, 1, -1};
int col[4] = {1, -1, 0, 0};

// Generated by 2.14.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can
// remove this line by using your custom template)
int main() {
  int H, W, K;
  cin >> H >> W >> K;
  vector<vector<char>> S(H, vector<char>(W));
  for (int i = 0; i < H; i++) {
    for (int j = 0; j < W; j++) {
      cin >> S[i][j];
    }
  }

  int ans = 0;

  stack<vector<pair<int, int>>> stack_paths;
  for (int i = 0; i < H; i++) {
    for (int j = 0; j < W; j++) {
      if (S[i][j] == '.') {
        vector<pair<int, int>> path;
        path.emplace_back(i, j);
        stack_paths.emplace(path);
        while (!stack_paths.empty()) {
          auto path = stack_paths.top();
          stack_paths.pop();

          auto coord = path.back();
          // loop adjacent cells
          bool isFound = false;
          for (int k = 0; k < 4; k++) {
            auto x = coord.first + row[k];
            auto y = coord.second + col[k];
            pair<int, int> target(x, y);
            auto it = find(path.begin(), path.end(), target);
            bool xIsInRange = (x >= 0) && (x < H);
            bool yIsInRange = (y >= 0) && (y < W);
            if (xIsInRange && yIsInRange && (S[x][y] == '.') && (it == path.end())) {
              isFound = true;
              auto new_path = path;
              new_path.emplace_back(target);
              stack_paths.emplace(new_path);
            }
          }
          if (!isFound) {
            int size = path.size();
            if (size > K) {
              ans++;
            }
          }
        }
      }
    }
  }

  cout << ans << endl;

  return 0;
}
