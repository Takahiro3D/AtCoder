#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;

const int INF = numeric_limits<int>::max();
const vector<int> moveH = {-1, 1, 0, 0};
const vector<int> moveW = {0, 0, 1, -1};
const vector<char> route = {'v', '^', '<', '>'};

auto solve(auto H, auto W, const std::vector<std::vector<char>> &S) {
  auto ans = S;

  auto exits = [&]() {
    vector<pair<int, int>> exits;
    REP(i, H) {
      REP(j, W) {
        if (S[i][j] == 'E') {
          exits.emplace_back(i, j);
        }
      }
    }
    return exits;
  }();

  vector<vector<int>> dist(H, vector<int>(W, INF));
  priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
  for (auto exit : exits) {
    pq.emplace(0, exit.first, exit.second);
  }

  while (!pq.empty()) {
    auto [cost, x, y] = pq.top();
    pq.pop();
    REP(i, 4) {
      auto moveX = x + moveH[i];
      auto xIsInRange = moveX >= 0 && moveX < H;
      auto moveY = y + moveW[i];
      auto yIsInRange = moveY >= 0 && moveY < W;
      if (xIsInRange && yIsInRange && ans[moveX][moveY] == '.' && cost < dist[moveX][moveY]) {
        ans[moveX][moveY] = route[i];
        pq.emplace(cost + 1, moveX, moveY);
      }
    }
  }

  return ans;
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int H, W;
  std::cin >> H >> W;
  std::vector<std::vector<char>> S(H, std::vector<char>((W)));
  REP(i, H) {
    REP(j, W) { std::cin >> S[i][j]; }
  }
  auto ans = solve(H, W, S);
  REP(i, H) {
    REP(j, W) { std::cout << ans[i][j]; }
    std::cout << '\n';
  }
  return 0;
}
