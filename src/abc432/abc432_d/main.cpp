#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;

struct Cluster {
  int x_min;
  int y_min;
  int x_max;
  int y_max;
};

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int N, X, Y;
  cin >> N >> X >> Y;
  vector<Cluster> clusters;
  clusters.emplace_back(Cluster{0, 0, X, Y});

  REP(i, N) {
    char C;
    int A, B;
    cin >> C >> A >> B;

    vector<Cluster> tmp;
    if (C == 'X') {
      for (auto& cluster : clusters) {
        if (cluster.x_max < A) {
          // Right cluster move up
          cluster.y_min += B;
          cluster.y_max += B;
          tmp.push_back(cluster);
        } else if (cluster.x_min >= A) {
          // Left cluster move down
          cluster.y_min -= B;
          cluster.y_max -= B;
          tmp.push_back(cluster);
        } else {
          // Split case
          tmp.emplace_back(A, cluster.y_min + B, cluster.x_max, cluster.y_max + B);
          tmp.emplace_back(cluster.x_min - B, cluster.y_min, A, cluster.y_max - B);
        }
      }
    } else {
      for (auto cluster : clusters) {
        if (cluster.y_max < A) {
          // Up cluster move right
          cluster.x_min += B;
          cluster.x_max += B;
          tmp.push_back(cluster);
        } else if (cluster.y_min >= A) {
          // Down cluster move left
          cluster.x_min -= B;
          cluster.x_max -= B;
          tmp.push_back(cluster);
        } else {
          // Split case
          tmp.emplace_back(cluster.x_min + B, A, cluster.x_max + B, cluster.y_max);
          tmp.emplace_back(cluster.x_min - B, cluster.y_min, A, cluster.y_max);
        }
      }
    }
    swap(clusters, tmp);
  }

  vector<vector<int>> connections;
  for (int i = 0; i < (int)clusters.size(); ++i) {
    for (int j = i + 1; j < (int)clusters.size(); ++j) {
      auto& c1 = clusters[i];
      auto& c2 = clusters[j];
    }
  }

  return 0;
}
