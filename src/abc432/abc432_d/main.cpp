#include <bits/stdc++.h>

#include <atcoder/all>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
using namespace atcoder;

struct Rect {
  int64_t x_min;
  int64_t y_min;
  int64_t x_max;
  int64_t y_max;
};

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int64_t N, X, Y;
  cin >> N >> X >> Y;
  vector<Rect> rects;
  rects.emplace_back(Rect{0, 0, X, Y});

  REP(i, N) {
    char C;
    int64_t A, B;
    cin >> C >> A >> B;

    vector<Rect> tmp;
    if (C == 'X') {
      for (auto& rect : rects) {
        if (rect.x_min >= A) {
          // Right rect move up
          rect.y_min += B;
          rect.y_max += B;
          tmp.push_back(rect);
        } else if (rect.x_max <= A) {
          // Left rect move down
          rect.y_min -= B;
          rect.y_max -= B;
          tmp.push_back(rect);
        } else {
          // Split case
          tmp.emplace_back(A, rect.y_min + B, rect.x_max, rect.y_max + B);
          tmp.emplace_back(rect.x_min, rect.y_min - B, A, rect.y_max - B);
        }
      }
    } else {
      for (auto rect : rects) {
        if (rect.y_min >= A) {
          // Up rect move right
          rect.x_min += B;
          rect.x_max += B;
          tmp.push_back(rect);
        } else if (rect.y_max <= A) {
          // Down rect move left
          rect.x_min -= B;
          rect.x_max -= B;
          tmp.push_back(rect);
        } else {
          // Split case
          tmp.emplace_back(rect.x_min + B, A, rect.x_max + B, rect.y_max);
          tmp.emplace_back(rect.x_min - B, rect.y_min, rect.x_max - B, A);
        }
      }
    }
    swap(rects, tmp);
  }

  int size = rects.size();
  dsu uf(size);
  for (int i = 0; i < size; ++i) {
    for (int j = i + 1; j < size; ++j) {
      auto& r1 = rects[i];
      auto& r2 = rects[j];
      auto cx = min(r1.x_max, r2.x_max) - max(r1.x_min, r2.x_min);
      auto cy = min(r1.y_max, r2.y_max) - max(r1.y_min, r2.y_min);
      if (cx < 0 || cy < 0) {
        // No overlap
        continue;
      }
      if (cx > 0 || cy > 0) {
        // Overlap x or y
        uf.merge(i, j);
      }
    }
  }

  vector<int64_t> areas(size, 0);
  REP(i, size) {
    auto& r = rects[i];
    int64_t area = (r.x_max - r.x_min) * (r.y_max - r.y_min);
    areas[uf.leader(i)] += area;
  }
  sort(areas.rbegin(), areas.rend());
  while (areas.back() == 0) areas.pop_back();
  reverse(areas.begin(), areas.end());
  cout << areas.size() << endl;
  for (auto area : areas) {
    cout << area << " ";
  }

  return 0;
}
