#include <algorithm>
#include <bitset>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <deque>
#include <fstream>
#include <functional>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
using namespace std;

struct Food {
  int x;
  int y;
};

// constexpr size_t MAX_FOODS = 200000000000000;
constexpr size_t MAX_FOODS = 200;

struct State {
  long long totalX, totalY;
  int count;
  bitset<MAX_FOODS> used;
  bool operator>(const State& other) const { return count > other.count; }
};

// Generated by 2.14.0 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can
// remove this line by using your custom template)
int main() {
  int64_t N, X, Y;
  cin >> N >> X >> Y;

  vector<Food> foods(N);
  for (auto& food : foods) {
    cin >> food.x;
  }
  for (auto& food : foods) {
    cin >> food.y;
  }

  // 1. loop min num foods with pritority que
  // 2. search next states the conditions are fulfilled such as BFS
  // Complexity: O(N * V logV)
  // V : num of states
  priority_queue<State, vector<State>, greater<State>> pq;
  pq.push({0, 0, 0});

  // visited state map [totalA][totalB] -> count
  unordered_map<long long, unordered_map<long long, int>> visited;

  while (!pq.empty()) {
    auto [totalX, totalY, count, used] = pq.top();
    pq.pop();

    // Output count if question conditions are fulfilled.
    // if (totalX > X && totalY > Y) {
    if (totalX > X || totalY > Y) {
      cout << count << endl;
      return 0;
    }

    // Update visited state if the state is new or smaller count
    if (visited[totalX].count(totalY) && count >= visited[totalX][totalY]) {
      continue;
    }
    visited[totalX][totalY] = count;

    // search next state
    for (size_t i = 0U; i < foods.size(); i++) {
      if (!used[i]) {
        long long nextA = totalX + foods[i].x;
        long long nextB = totalY + foods[i].y;
        int nextCount = count + 1;
        auto nextUsed = used.set(i);

        // Set queue if the state is new or smaller count
        if (!visited[nextA].count(nextB) || nextCount < visited[nextA][nextB]) {
          pq.push({nextA, nextB, nextCount, nextUsed});
        }
      }
    }
  }

  cout << N << endl;

  return 0;
}
