#include <bits/stdc++.h>

#include <atcoder/all>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
using namespace atcoder;

void solve() {
  int64_t N, M;
  cin >> N >> M;
  vector<int> X(N);
  REP(i, N) { cin >> X[i]; }
  vector<int> Y(M);
  REP(i, M) { cin >> Y[i]; }

  // Store original indices
  unordered_map<int, int> row_idx;
  REP(i, N) { row_idx[X[i]] = i; }
  unordered_map<int, int> col_idx;
  REP(i, M) { col_idx[Y[i]] = i; }

  // sort X, Y descending order
  sort(ALL(X));
  reverse(ALL(X));
  sort(ALL(Y));
  reverse(ALL(Y));

  vector a(N, vector<int>(M, 0));
  auto Xi = 0;
  auto Yj = 0;
  vector<pair<int, int>> cells;
  for (int v = N * M; v >= 1; v--) {
    // candidate cells row direction
    if (Xi < N && X[Xi] == v) {
      REP(j, Yj) { cells.emplace_back(Xi, j); }
      Xi++;
    }
    // candidate cells column direction
    if (Yj < M && Y[Yj] == v) {
      REP(i, Xi) { cells.emplace_back(i, Yj); }
      Yj++;
    }
    if (cells.empty()) {
      cout << "No\n";
      return;
    }
    // get a cell smallest cabdudate
    auto [i, j] = cells.back();
    cells.pop_back();
    a[i][j] = v;
  }

  vector ans(N, vector<int>(M, 0));
  REP(i, N) {
    REP(j, M) { ans[row_idx[X[i]]][col_idx[Y[j]]] = a[i][j]; }
  }
  cout << "Yes\n";
  REP(i, N) {
    REP(j, M) { cout << ans[i][j] << " "; }
    cout << "\n";
  }
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int T;
  cin >> T;
  REP(t, T) { solve(); }
  return 0;
}
