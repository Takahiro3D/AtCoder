#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;

int move_h[] = {0, 0, 1, -1};
int move_w[] = {1, -1, 0, 0};

int64_t solve(int H, int W, const std::vector<std::string> &S, int A, int B, int64_t C, int64_t D) {
  using Coord = pair<int, int>;
  priority_queue<pair<int, Coord>, vector<pair<int, Coord>>, greater<pair<int, Coord>>> pq;
  vector<vector<int>> costs(H, vector<int>(W, INT32_MAX));
  vector<vector<bool>> visited(H, vector<bool>(W));
  A--;
  B--;
  C--;
  D--;

  pq.emplace(0, Coord(A, B));
  while (!pq.empty()) {
    auto [cost, coord] = pq.top();
    pq.pop();

    if (visited[coord.first][coord.second]) {
      continue;
    }

    costs[coord.first][coord.second] = cost;
    visited[coord.first][coord.second] = true;

    REP(i, 4) {
      Coord move = {coord.first + move_h[i], coord.second + move_w[i]};
      auto h_is_inrange = (move.first >= 0) && (move.first < H);
      auto w_is_inrange = (move.second >= 0) && (move.second < W);
      if (h_is_inrange && w_is_inrange) {
        if (S[move.first][move.second] == '.') {
          pq.emplace(cost, move);
        } else {
          // move kick
          pq.emplace(cost + 1, move);

          Coord move2 = {move.first + move_h[i], move.second + move_w[i]};
          auto h_is_inrange = (move2.first >= 0) && (move2.first < H);
          auto w_is_inrange = (move2.second >= 0) && (move2.second < W);
          if (h_is_inrange && w_is_inrange) {
            pq.emplace(cost + 1, move2);
          }
        }
      }
    }
  }

  return costs[C][D];
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int H, W, A, B, C, D;
  std::cin >> H >> W;
  std::vector<std::string> S(H);
  REP(i, H) { std::cin >> S[i]; }
  std::cin >> A >> B >> C >> D;
  auto ans = solve(H, W, S, A, B, C, D);
  std::cout << ans << '\n';
  return 0;
}
