#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;

int move_h[] = {0, 0, 1, -1};
int move_w[] = {1, -1, 0, 0};

int64_t solve(int H, int W, const std::vector<std::string> &S, int A, int B, int64_t C, int64_t D) {
  using Coord = pair<int, int>;
  deque<pair<int, Coord>> q;
  vector<vector<int>> costs(H, vector<int>(W, INT32_MAX));
  vector<vector<bool>> visited(H, vector<bool>(W));
  A--;
  B--;
  C--;
  D--;

  auto push = [&](int cost, Coord coord, int c) {
    if (cost >= costs[coord.first][coord.second]) {
      return;
    }
    if (c == 0) {
      q.emplace_front(cost, coord);
    } else {
      cost++;
      q.emplace_back(cost, coord);
    }
    costs[coord.first][coord.second] = cost;
  };

  push(0, Coord(A, B), 0);
  while (!q.empty()) {
    auto [cost, coord] = q.front();
    q.pop_front();

    if (visited[coord.first][coord.second]) {
      continue;
    }
    visited[coord.first][coord.second] = true;

    REP(i, 4) {
      Coord move = {coord.first + move_h[i], coord.second + move_w[i]};
      auto h_is_inrange = (move.first >= 0) && (move.first < H);
      auto w_is_inrange = (move.second >= 0) && (move.second < W);
      if (h_is_inrange && w_is_inrange) {
        if (S[move.first][move.second] == '.') {
          push(cost, move, 0);
        } else {
          // move kick
          push(cost, move, 1);

          Coord move2 = {move.first + move_h[i], move.second + move_w[i]};
          auto h_is_inrange = (move2.first >= 0) && (move2.first < H);
          auto w_is_inrange = (move2.second >= 0) && (move2.second < W);
          if (h_is_inrange && w_is_inrange) {
            push(cost, move2, 1);
          }
        }
      }
    }
  }

  return costs[C][D];
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int H, W, A, B, C, D;
  std::cin >> H >> W;
  std::vector<std::string> S(H);
  REP(i, H) { std::cin >> S[i]; }
  std::cin >> A >> B >> C >> D;
  auto ans = solve(H, W, S, A, B, C, D);
  std::cout << ans << '\n';
  return 0;
}
