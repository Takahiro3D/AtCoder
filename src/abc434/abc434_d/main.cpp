#include <bits/stdc++.h>

#include <atcoder/all>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
using namespace atcoder;

struct Cloud {
  int u;
  int d;
  int l;
  int r;
};

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int64_t N;
  cin >> N;

  vector<Cloud> clouds(N);
  REP(i, N) {
    cin >> clouds[i].u >> clouds[i].d >> clouds[i].l >> clouds[i].r;
    clouds[i].u--;
    clouds[i].d--;
    clouds[i].l--;
    clouds[i].r--;
  }

  int64_t LEN = 2000;
  vector<vector<pair<int, int>>> grid(LEN);
  REP(i, N) {
    for (int y = clouds[i].u; y <= clouds[i].d; ++y) {
      grid[y].emplace_back(clouds[i].l, clouds[i].r);
    }
  }
  int64_t fill = 0;
  REP(i, LEN) {
    if (grid[i].empty()) {
      continue;
    }
    sort(ALL(grid[i]));
    auto tmp_l = -1;
    auto tmp_r = -1;
    for (auto [l, r] : grid[i]) {
      r++;
      if (l > tmp_r) {
        // new segment
        fill += tmp_r - tmp_l;
        tmp_l = l;
        tmp_r = r;
      } else {
        // extend segment
        tmp_r = max(tmp_r, r);
      }
    }
    // last segment
    fill += tmp_r - tmp_l;
  }

  REP(i, N) {
    auto ans = fill;
    for (int y = clouds[i].u; y <= clouds[i].d; ++y) {
      std::pair<int, int> target = {clouds[i].l, clouds[i].r};
      auto it = std::lower_bound(ALL(grid[y]), target);
      auto idx = distance(grid[y].begin(), it);
      auto tmp_l = clouds[i].l;
      for (int i = idx - 1; i >= 0; i--) {
        auto [l, r] = grid[y][i];
        tmp_l = max(tmp_l, r + 1);
      }
      auto tmp_r = clouds[i].r;
      for (int i = idx + 1; i < (int)grid[y].size(); i++) {
        auto [l, r] = grid[y][i];
        if (r < tmp_r) {
          break;
        } else {
          tmp_r = min(tmp_r, l);
        }
      }
      auto len = max(tmp_r - tmp_l, 0);
      ans -= len;
    }
    cout << LEN * LEN - ans << endl;
  }

  return 0;
}
