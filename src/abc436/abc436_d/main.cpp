#include <bits/stdc++.h>

#include <atcoder/all>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;
using namespace atcoder;

using Coord = pair<int, int>;

constexpr int dh[] = {-1, 1, 0, 0};
constexpr int dw[] = {0, 0, -1, 1};

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);

  int64_t H, W;
  cin >> H >> W;
  vector<string> S(H);
  REP(i, H) { cin >> S[i]; }
  unordered_map<char, vector<Coord>> warp;
  REP(i, H) {
    REP(j, W) {
      char c = S[i][j];
      if ('a' <= c && c <= 'z') {
        warp[c].emplace_back(i, j);
      }
    }
  }

  // Dijkstra method
  const int64_t INF = 1LL << 60;
  vector<vector<int64_t>> dist(H, vector<int64_t>(W, INF));
  using P = pair<int64_t, Coord>;  // (distance, (h, w))
  priority_queue<P, vector<P>, greater<P>> pq;
  dist[0][0] = 0;
  pq.push({0, {0, 0}});
  while (!pq.empty()) {
    const auto [d, hw] = pq.top();
    pq.pop();
    const auto [h, w] = hw;
    if (dist[h][w] < d) {
      continue;
    }
    REP(dir, 4) {
      int nh = h + dh[dir];
      int nw = w + dw[dir];
      if (nh < 0 || nh >= H || nw < 0 || nw >= W) {
        continue;
      }
      if (S[nh][nw] == '#') {
        continue;
      }
      if (d < dist[nh][nw] - 1) {
        dist[nh][nw] = d + 1;
        pq.push({d + 1, {nh, nw}});
      }
    }
    if (S[h][w] >= 'a' && S[h][w] <= 'z') {
      char c = S[h][w];
      for (const auto& [wh, ww] : warp[c]) {
        if (wh == h && ww == w) {
          continue;
        }
        if (d < dist[wh][ww] - 1) {
          dist[wh][ww] = d + 1;
          pq.push({d + 1, {wh, ww}});
        }
      }
      // Clear to avoid redundant warping
      warp[c].clear();
    }
  }

  if (dist[H - 1][W - 1] == INF) {
    cout << -1 << endl;
  } else {
    cout << dist[H - 1][W - 1] << endl;
  }

  return 0;
}
