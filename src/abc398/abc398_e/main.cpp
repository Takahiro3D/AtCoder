#include <bits/stdc++.h>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++(i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++(i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; --(i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); --(i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;

using P = pair<int, int>;

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n;
  std::cin >> n;
  std::vector<vector<int>> to(n);
  vector<P> erase;
  REP(i, n - 1) {
    int a, b;
    std::cin >> a >> b;
    a--;
    b--;
    to[a].emplace_back(b);
    to[b].emplace_back(a);
    erase.emplace_back(a, b);
  }

  // Create bipartie graph
  vector<vector<int>> bipartite_graph(2);
  auto dfs = [&](auto dfs, int vertex, int color, int parent = -1) -> void {
    bipartite_graph[color].emplace_back(vertex);
    for (int next : to[vertex]) {
      if (next == parent) continue;
      dfs(dfs, next, color ^ 1, vertex);
    }
  };
  dfs(dfs, 0, 0);

  // Create all edge
  set<P> can_edge;
  for (int a : bipartite_graph[0]) {
    for (int b : bipartite_graph[1]) {
      can_edge.emplace(min(a, b), max(a, b));
    }
  }
  // Remove input tree edge
  for (auto e : erase) {
    can_edge.erase(e);
  }

  auto me = (can_edge.size() % 2) == 1;
  if (me) {
    cout << "First" << endl;
  } else {
    cout << "Second" << endl;
  }

  while (true) {
    if (me) {
      auto it = can_edge.begin();
      auto [a, b] = *it;
      can_edge.erase(it);
      a++, b++;
      cout << a << ' ' << b << endl;
    } else {
      int a, b;
      cin >> a >> b;
      if (a == -1) break;
      a--;
      b--;
      can_edge.erase(P(a, b));
    }
    me = !me;
  }

  return 0;
}
